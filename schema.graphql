type Protocol @entity {
    # only one of these (id=1)
    id: ID!
    # address of price oracle the comptroller uses
    priceOracle: Bytes!
    # block number when the price oracle was last updated
    lastNewOracleBlockNumber: BigInt!

    # most recent block number where the protocol summary data was updated
    latestBlockNumber: BigInt!
    # all the markets that the comptroller controls
    markets: [Market!]! # this can't be a derived field as we need access to it in the historicalWeekData mapping
    # total supply of the entire protocol in USD
    totalSupplyUsd: BigDecimal!
    # total borrow of the entire protocol in USD
    totalBorrowUsd: BigDecimal!
    # total reserves of the entire protocol in USD
    totalReservesUsd: BigDecimal!
    # utilization of the entire protocol
    utilization: BigDecimal!

    # historical data in weekly intervals of the entire protocol
    historicalWeekData: [ProtocolWeekData!]! @derivedFrom(field: "protocol")
}

type Market @entity {
    # cToken address
    id: ID!
    # block number when the market was created
    creationBlockNumber: BigInt!
    # most recent block number where the market was updated
    latestBlockNumber: BigInt!
    # cToken symbol
    cTokenSymbol: String!
    # number of decimals of the cToken
    cTokenDecimals: BigInt!
    # underlying token name
    underlyingName: String!
    # underlying token symbol
    underlyingSymbol: String!
    # underlying token address
    underlyingAddress: Bytes!
    # number of decimals of the underlying token
    underlyingDecimals: BigInt!
    # comptroller address
    comptrollerAddress: Bytes!
    # total number of unique suppliers to the market
    numberOfSuppliers: BigInt!
    # total number of unique borrowers to the market
    numberOfBorrowers: BigInt!
    # list of all UserMarket positions that belong to this market
    userMarket: [UserMarket!]! @derivedFrom(field: market)
    # collator factor in decimal form
    collateralFactor: BigDecimal!
    # reserve factor in decimal form
    reserveFactor: BigDecimal!
    # borrow cap in underlying tokens
    borrowCap: BigDecimal!
    # amount of underlying owned by the contract
    cash: BigDecimal!
    # price of underlying tokens in cTokens
    cTokenPerUnderlying: BigDecimal!
    # supply rate per block, this is the value from the contract with the 10^18 scaling removed
    supplyRatePerBlock: BigDecimal!
    # borrow rate per block, this is the value from the contract with the 10^18 scaling removed
    borrowRatePerBlock: BigDecimal!
    # supply apy not including the COMP distribution in decimal form
    supplyApy: BigDecimal!
    # borrow apy not including the COMP distribution in decimal form
    borrowApy: BigDecimal!
    # total supply apy including the COMP distribution in decimal form
    totalSupplyApy: BigDecimal!
    # total borrow apy including the COMP distribution in decimal form
    totalBorrowApy: BigDecimal!
    # total amount of underlying tokens supplied
    totalSupply: BigDecimal!
    # total amount supplied in USD
    totalSupplyUsd: BigDecimal!
    # total amount of underlying tokens borrowed
    totalBorrow: BigDecimal!
    # total amount borrowed in USD
    totalBorrowUsd: BigDecimal!
    # total amount of underlying token in reserves
    totalReserves: BigDecimal!
    # total amount in reserves in USD
    totalReservesUsd: BigDecimal!
    # total available to be borrowed in the underlying asset
    availableLiquidity: BigDecimal!
    # total available to be borrowed in USD
    availableLiquidityUsd: BigDecimal!
    # utilization
    utilization: BigDecimal!
    # COMP distribution per block for suppliers, this is the value from the contract with the 10^18 scaling removed
    compSpeedSupply: BigDecimal!
    # COMP distribution per block for borrowers, this is the value from the contract with the 10^18 scaling removed
    compSpeedBorrow: BigDecimal!
    # number of usdc one underlying token is worth
    usdcPerUnderlying: BigDecimal!
    # number of usdc one eth is worth
    usdcPerEth: BigDecimal!
    # price of COMP token in USDC
    usdcPerComp: BigDecimal!

    # historical data in hourly intervals
    historicalHourData: [MarketHourData!]! @derivedFrom(field: "market")
    # historical data in daily intervals
    historicalDayData: [MarketDayData!]! @derivedFrom(field: "market")
    # historical data in weekly intervals
    historicalWeekData: [MarketWeekData!]! @derivedFrom(field: "market")
}

type MarketHourData @entity {
    # token address concatendated with date
    id: ID!
    # market that this data belongs to
    market: Market!
    # unix timestamp in seconds rounded to the start of the hour
    date: BigInt!
    # supply apy not including the COMP distribution in decimal form
    supplyApy: BigDecimal!
    # borrow apy not including the COMP distribution in decimal form
    borrowApy: BigDecimal!
    # total supply apy including the COMP distribution in decimal form
    totalSupplyApy: BigDecimal!
    # total borrow apy including the COMP distribution in decimal form
    totalBorrowApy: BigDecimal!
    # total amount of underlying tokens supplied over time
    totalSupply: BigDecimal!
    # total amount supplied in USD
    totalSupplyUsd: BigDecimal!
    # total amount of underlying tokens borrowed over time
    totalBorrow: BigDecimal!
    # total amount borrowed in USD
    totalBorrowUsd: BigDecimal!
    # total amount of underlying token in reserves over time
    totalReserves: BigDecimal!
    # total amount in reseres in USD
    totalReservesUsd: BigDecimal!
    # utilization
    utilization: BigDecimal!
    # price of the underlying token in USDC
    usdcPerUnderlying: BigDecimal!
    # number of usdc one eth is worth
    usdcPerEth: BigDecimal!
    # price of COMP token in USDC
    usdcPerComp: BigDecimal!

    # number of transactions that went into deriving this data entry
    txCount: BigInt!
}

type MarketDayData @entity {
    # token address concatendated with date
    id: ID!
    # market that this data belongs to
    market: Market!
    # unix timestamp in seconds rounded to the start of the day
    date: BigInt!
    # supply apy not including the COMP distribution in decimal form
    supplyApy: BigDecimal!
    # borrow apy not including the COMP distribution in decimal form
    borrowApy: BigDecimal!
    # total supply apy including the COMP distribution in decimal form
    totalSupplyApy: BigDecimal!
    # total borrow apy including the COMP distribution in decimal form
    totalBorrowApy: BigDecimal!
    # total amount of underlying tokens supplied over time
    totalSupply: BigDecimal!
    # total amount supplied in USD
    totalSupplyUsd: BigDecimal!
    # total amount of underlying tokens borrowed over time
    totalBorrow: BigDecimal!
    # total amount borrowed in USD
    totalBorrowUsd: BigDecimal!
    # total amount of underlying token in reserves over time
    totalReserves: BigDecimal!
    # total amount in reseres in USD
    totalReservesUsd: BigDecimal!
    # utilization
    utilization: BigDecimal!
    # price of the underlying token in USDC
    usdcPerUnderlying: BigDecimal!
    # number of usdc one eth is worth
    usdcPerEth: BigDecimal!
    # price of COMP token in USDC
    usdcPerComp: BigDecimal!
    # number of transactions that went into deriving this data entry
    txCount: BigInt!
}

type MarketWeekData @entity {
    # token address concatendated with date
    id: ID!
    # market that this data belongs to
    market: Market!
    # unix timestamp in seconds rounded to the start of the week
    date: BigInt!
    # supply apy not including the COMP distribution in decimal form
    supplyApy: BigDecimal!
    # borrow apy not including the COMP distribution in decimal form
    borrowApy: BigDecimal!
    # total supply apy including the COMP distribution in decimal form
    totalSupplyApy: BigDecimal!
    # total borrow apy including the COMP distribution in decimal form
    totalBorrowApy: BigDecimal!
    # total amount of underlying tokens supplied over time
    totalSupply: BigDecimal!
    # total amount supplied in USD
    totalSupplyUsd: BigDecimal!
    # total amount of underlying tokens borrowed over time
    totalBorrow: BigDecimal!
    # total amount borrowed in USD
    totalBorrowUsd: BigDecimal!
    # total amount of underlying token in reserves over time
    totalReserves: BigDecimal!
    # total amount in reseres in USD
    totalReservesUsd: BigDecimal!
    # utilization
    utilization: BigDecimal!
    # price of the underlying token in USDC
    usdcPerUnderlying: BigDecimal!
    # number of usdc one eth is worth
    usdcPerEth: BigDecimal!
    # price of COMP token in USDC
    usdcPerComp: BigDecimal!
    # number of transactions that went into deriving this data entry
    txCount: BigInt!
}

type ProtocolWeekData @entity {
    # token address concatendated with date
    id: ID!
    # comptroller of the protocol
    protocol: Protocol!
    # unix timestamp in seconds rounded to the start of the week
    date: BigInt!
    # total amount of supplied in USD of the entire protocol
    totalSupplyUsd: BigDecimal!
    # total amount of borrowed in USD of the entire protocol
    totalBorrowUsd: BigDecimal!
    # total amount of reserves in USD of the entire protocol
    totalReservesUsd: BigDecimal!
    # utilization
    utilization: BigDecimal!
    # number of transactions that went into deriving this data entry
    txCount: BigInt!
}

type User @entity {
    # users wallet address
    id: ID!
    # most recent block number where the user was updated
    lastBlockNumber: BigInt!
    # list of all UserMarket positions that belong to this user 
    userMarkets: [UserMarket!]! @derivedFrom(field: user)
    # aggregate total of all supplied tokens by the user in all markets in USD
    totalSupplyUsd: BigDecimal!
    # aggregate total of all borrowed tokens by the user in all markets in USD
    totalBorrowUsd: BigDecimal!
}

# Pairing for a single user to a single market, this repesents a users position in a market
type UserMarket @entity {
    # concatenation of market cToken address and user address
    id: ID!
    # market in pairing
    market: Market!
    # user in pairing
    user: User!
    # most recent block number where the AccountMarket was updated
    latestBlockNumber: BigInt!
    # if the market is entered by the user 
    enteredMarket: Boolean!
    # total amount of underlying supplied by the user to the market
    totalSupply: BigDecimal!
    # total amount of underlying borrowed by the user from the market
    totalBorrow: BigDecimal!
    # number of cTokens of this market the user owns
    cTokenBalance: BigInt!
    # transactions made by the user associated with this market 
    transactions: [Transaction!]! @derivedFrom(field: userMarket)
    # list of all liquidations the user has recieved in this market (i.e user had their borrow repayed in the markets underlying asset)
    receivedLiquidations: [Liquidation!]! @derivedFrom(field: borrowerMarket)
    # list of all liquidations the user had performed where they seized cTokens of this market (i.e user repayed another users borrow)
    performedLiquidations: [Liquidation!]! @derivedFrom(field: liquidatorMarket)
}

enum TransactionType {
    MINT
    REDEEM
    BORROW
    REPAY
    TRANSFER
}

# mint: underlying <-> ctoken
# redeem: cToken <-> underlying
# borrow: underlying
# repay: underlying
# transfer: cToken
type Transaction @entity {
    # transaction hash 
    id: ID!
    # block number the transation occured
    blockNumber: BigInt! 
    # unix timestamp in seconds the transaction was made 
    date: BigInt!
    # the type of the transaction
    type: TransactionType!
    # UserMarket the transaction belongs to
    userMarket: UserMarket!
    # underlying amount for the part of the transaction in the underlying token, this will be zero for TRANSFER
    underlyingAmount: BigDecimal!
    # cToken amount for the part of the transaction in cTokens, this will be zero for BORROW and REPAY 
    cTokenAmount: BigDecimal!
}

# liquidation: underlying token from borrowerMarket's market <-> cTokens of liquidatorMarket's market
type Liquidation @entity {
    # transaction hash concat with ?? (TODO)
    id: ID!
    # block number of the liquidation
    blockNumber: BigInt!
    # unix timestamp in seconds the transaction was made 
    date: BigInt!
    # user being liquidated, and the market they are being liquidated in
    borrowerMarket: UserMarket!
    # user doing the liquidation, and the market they are seizing cTokens in
    liquidatorMarket: UserMarket!
    # amount of the underlying tokens of borrowerMarket's market which are being repayed by the liquidator
    repayAmount: BigDecimal!
    # amount of the cTokens of liquidatorMarket's market which are being seized by the liquidator 
    seizeAmount: BigDecimal!
}
